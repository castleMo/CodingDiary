# CPU 스케쥴링(Scheduling)

## 스케쥴링이란?
한정된 자원으로 최대한 성능을 이끌어내기 위해서는 CPU를 적절하고 효율적으로 사용해야 한다.

따라서 OS는 실행 대기중인 프로세스들에게 자원 배정을 적절히 하여 시스템의 성능을 끌어올릴 수 있다.


## 선점 스케쥴링(Preemptive Scheduling)
OS가 나서서 CPU사용권을 '선점'하고, 특정 요건에 따라 각 프로세스의 요청이 있을 때 프로세스에게 분배하는 방식이다. 

가장 자원이 필요한 프로세스에게 CPU를 분배하며 상황에 따라 강제로 회수할 수도 있다. 

따라서 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하며 긴급한 프로세스를 제어할 수 있다. 


## 비선점 스케쥴링(Non-Preemptive Scheduling)
어떤 프로세스가 CPU를 할당받으면 그 프로세스가 종료되거나, 입출력 요구가 발생하여 자발적으로 중지될 때 까지 계속 실행되도록 보장한다. 

순서대로 처리되는 공정성이 있고, 다음에 처리해야할 프로세스와 상관없이 응답시간을 예상할 수 있으며 
선점방식보다 스케쥴러 호출 빈도가 낮고, 문맥교환에 의한 오버헤드가 적다.

일괄처리 시스템에 적합하며 자칫 CPU사용시간이 긴 프로세스가 다른 프로세스들을 대기시킬 수 있으므로 처리율이 떨어질 수 있다는 단점이 있다.


## 스케쥴링의 종류
### FCFS (First Come , First Serve)

먼저 도착한 프로세스를 먼저 처리하는 스케쥴링 알고리즘이다. 비 선점형이며 FIFO큐를 이용하여 간단하게 구현한다.

다만 Convoy Effect(호위효과)가 발생하는데, 긴 처리시간의 프로세스가 선점되어버리면 나머지 프로세스들은 끝날때 까지 대기해야 한다.

따라서 먼저 도착한 프로세스의 버스트 타임에 따라서 평균 대기시간의 편차가 크다. 


### SJF(Shorted Job First)
최단작업우선 스케쥴링 알고리즘이다. 

여기서 최단작업이란 CPU버스트 타임이 가장 짦은 프로세스를 말한다. 

따라서 가장 적은 평균 대기 시간을 달성할 수 있다. 

만약 CPU버스트 시간이 동일하다면 FCFS방식을 따른다. 

다만 선점형인 경우에는 위와같이 진행이 되지만 비 선점형일 경우엔 최소잔여시간우선 법칙을 따른다. 

현재 CPU에 할당된 프로세스의 남은 잔여시간과, 새로 들어온 프로세스의 CPU버스트 타임을 비교하여 더 적은 프로세스에게 할당하게끔 한다.


### Priority Scheduling(우선순위 스케쥴링)
미리 주어진 프로세스의 우선순위에 따라서 스케쥴링하는 방식이다. 

2번에서 다룬 SJF도 Priority Scheduling의 일종이다.

(최소 버스트 시간 기준) 그러나 우선순위가 낮은 프로세스는 할당되지 않기도 하는데, 이를 기아(Starvation)이라고 부른다. 

이를 방지하기 위한 해결법으로는 노화(Aging)이 있는데 기다리는 시간에 따라 우선순위를 증가시켜주는 방식이다. 

마찬가지로 우선순위가 같으면 FCFS를 적용한다. 

선점형과 비선점형이 있다. 


### Round Robin(라운드로빈)
정해진 시간 할당량만큼 프로세스를 할당한 뒤, 작업이 끝난 프로세스는 준비완료 큐(순환 큐)의 가장 마지막에 가서 재할당을 기다린다.

시간 할당량이 중요한데, 너무 작으면 빈번한 Context Switching이 발생하고, 너무 길면 FCFS와 다를 바 없어진다. 통산 10~100ms사이이다.

선점형 알고리즘이다.


<br>
<br>

> 참고  
> - https://dduddublog.tistory.com/23

